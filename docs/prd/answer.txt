 🔍 비즈니스 규칙 구체화 질문

  📦 CrawlTask 생성 관련

  1. EventBridge → API Server 연동:
  - ❓ API 엔드포인트 형식은? POST /api/v1/crawl/trigger?schedulerId={id} vs POST /api/v1/crawl/trigger (body에 schedulerId)?
  - ❓ EventBridge에서 인증은? (API Key? IAM Role?)

  2. Scheduler 조회 후 CrawlTask 생성:
  - ❓ Scheduler가 비활성 상태(PAUSED/DISABLED)면 어떻게 처리? 에러
  - ❓ 동일 Scheduler에 대해 중복 트리거 방지 필요? 이미 WAITING/RUNNING 상태면 skip
  - ❓ CrawlTask에 포함될 정보는?
    - sellerId (from Scheduler)
    - endpoint (미니샵 목록 API)
    - page (첫 페이지부터?)
    - 기타?

  3. Task 생성 전략:
  - ❓ 한 번 트리거에 생성되는 Task 수는 우선 메타데이터(미니샵)을 크롤링 태스크 한개 발행-> 워커에서  상품수를 알아냄 -> 상품수 / 500 만큼의 미니샵 태스크 발행 -> 이런식
  - ❓ 아니면 첫 번째 Task만 생성하고, Worker가 다음 Task를 생성하는 구조가 맞다

  ---
  🚀 SQS 발행 관련

  4. Outbox 패턴 vs 직접 발행:
  - ❓ 크롤 태스크 저장 및 크롤 태스크 메세지 Outbox 테이블에 저장 후 이벤트 커밋 리스너에서 sqs로 메세지 전송 -> 크롤 태스크 메세지 아웃박스 완료 처리
  - ❓ 해피패스가 실패(애프터커밋 이벤트 리스너, 별도 스레드)를 대비해 폴백용 스케쥴러 부트스트랩 구성할 예정

  5. SQS 메시지 형식:
  - ❓ 메시지 body에 포함될 정보는?
    - Idempotency Key
    - taskId
    - requestUrl
    - retryCount

  6. 멱등성 보장:
  - ❓ 같은 Task가 중복 발행되면 어떻게 처리? Idempotency Key로

  ---
  ⚠️ 에러 처리 관련

  7. Scheduler 조회 실패:
  - ❓ Scheduler가 존재하지 않으면? (404)

  8. SQS 발행 실패:
  - ❓ 재시도 전략은? Outbox 재발행보단 리트라이 카운트까지 재시도하는 폴백용 스케쥴러를 둘까?

  ---
  🔄 Transaction 경계

  9. Transaction 범위:
  - ❓ Scheduler 조회 + CrawlTask 저장 + Outbox 저장까지 하나의 트랜잭션
  - ❓ SQS 발행은 트랜잭션 밖

