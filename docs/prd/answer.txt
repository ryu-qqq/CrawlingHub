 핵심 기능:
  1. Seller 바운더리 컨텍스트: 셀러 등록/상태 변경
  2. Crawling Scheduler 바운더리 컨텍스트: 크롤링 스케줄 관리 + AWS EventBridge 연동

  이제 구체적인 비즈니스 규칙을 함께 정의해보겠습니다!

  ---
  📋 1단계: 프로젝트 개요 확인

  제가 이해한 내용이 맞는지 확인해주세요:

  비즈니스 목적:
  - 머스트잇 사이트의 셀러별 상품 정보를 주기적으로 크롤링
  - AWS EventBridge를 통한 스케줄 기반 크롤링 자동화

  주요 사용자:
  - 관리자 (셀러 등록, 스케줄 관리)

  성공 기준:
  - 스케줄 등록 시 AWS EventBridge와 100% 동기화
  - 셀러 비활성화 시 관련 스케줄 모두 자동 비활성화
  - 스케줄 변경 이력 추적 가능

  맞나요? 추가하거나 수정할 내용이 있으신가요?
  
  -> 없어 맞어 

  ---
  🏗️ 2단계: Domain Layer 비즈니스 규칙 구체화

  📦 Seller Aggregate

  제가 이해한 Seller의 핵심 속성과 규칙입니다:

  속성:
  - sellerId: Long (내부 ID, AutoIncrement)
  - mustItSellerId: String (머스트잇 노출 ID)
  - sellerName: String
  - status: SellerStatus (ACTIVE, INACTIVE)
  - createdAt, updatedAt

  비즈니스 규칙 - 이 부분을 함께 구체화하고 싶습니다!

  🔍 Seller 등록 (Register Seller)

  1. 머스트잇 셀러 ID 검증:
    - ❓ mustItSellerId 형식 제약이 있나요? 없음
    - ❓ 중복된 mustItSellerId로 등록 시도 시 처리는? 예외 발생
    - ❓ mustItSellerId는 변경 불가
  2. 초기 상태:
    - ✅ 기본 상태는 ACTIVE (확인됨)
    - ❓ 등록 시 추가 검증 필요한가요? 없음
  3. 셀러명 관리:
    - ❓ sellerName은 필수
    - ❓ 셀러명 중복 불가
    - ❓ 셀러명 변경 불가

  ---
  🔍 Seller 상태 변경 (Change Status)

  ACTIVE → INACTIVE 전환:
  - ✅ 비활성화 시 관련 스케줄 모두 비활성화 필수 (확인됨)
  - ❓ 비활성화 실패 시나리오 처리:
    - 만약 AWS EventBridge 비활성화 API 호출이 실패하면?
      - C) 셀러는 INACTIVE로 변경, 재시도 로직 추가 (Outbox Pattern)
  - ❓ 스케줄 비활성화 순서:
    - 아니면 셀러 상태 변경 후 스케줄 비활성화 (Event-driven)

  INACTIVE → ACTIVE 재활성화:
  - ❓ 재활성화 가능
  - ❓ 재활성화 시 스케줄도 수동으로 개별 활성화

  ---
  📦 Crawling Scheduler Aggregate

  속성:
  - schedulerId: Long
  - sellerId: Long (FK - Long FK 전략)
  - schedulerName: String (Unique per Seller)
  - cronExpression: String (예: "0 0 * * * *")
  - status: SchedulerStatus (ACTIVE, INACTIVE)
  - eventBridgeRuleName: String (AWS Rule 이름)
  - createdAt, updatedAt

  비즈니스 규칙 - 함께 구체화할 부분:

  🔍 스케줄 등록 (Register Scheduler)

  1. 스케줄러 이름 중복 처리:
    - ✅ 동일 Seller 내에서 schedulerName 중복 불가 (확인됨)
    - ❓ 다른 Seller 간에는 같은 schedulerName 사용 가능
    - ❓ 중복 시도 시 처리는? 예외
  2. Cron Expression 검증:
    - ❓ Cron 형식 검증은 누가 하나요? Domain
    - ❓ 지원하는 Cron 형식은? AWS EventBridge 제약사항 준수
    - ❓ 최소 실행 간격 제약이 있나요? 최소 1시간 간격
  3. EventBridge Rule 생성:
    - ❓ eventBridgeRuleName 생성 규칙은? 예: {sellerName}-{schedulerName}-{timestamp}
    - ❓ AWS EventBridge Rule 생성 실패 시 처리는?
      - B) Scheduler는 저장 아웃박스도 함께 저장, 성공하면 아웃박스 성공처리 실패하면 Outbox기준으로 재시도 
      
  4. 초기 상태:
    - ❓ 등록 시 기본 상태는 PENDING 
    - ❓ INACTIVE 상태 Seller의 스케줄 등록 불가

  ---
  🔍 스케줄 수정 (Update Scheduler)

  수정 가능 항목:
  - ❓ 어떤 항목을 수정할 수 있나요?
    - schedulerName 변경 가능 (중복 체크 다시 필요)
    - cronExpression 변경 가능 (AWS Rule 업데이트 필요)
    - status 변경 가능 (ACTIVE ↔ INACTIVE)

  수정 시 EventBridge 동기화:
  - ❓ Cron 변경 시 AWS EventBridge Rule도 즉시 업데이트 무조건 아웃박스도 저장
  - ❓ 업데이트 실패 시 처리는 ( Outbox 재시도)

  수정 이력 관리:
  - ✅ 히스토리 테이블 필요 (확인됨)
  - ❓ 어떤 정보를 기록하나요?
    - 변경 전/후 값 (Old/New cronExpression, status 등)
    - 변경 일시

  ---
  🔍 스케줄 비활성화 (Deactivate Scheduler)

  개별 비활성화:
  - ❓ 개별 스케줄 비활성화 가능한가요
  - ❓ 비활성화 시 AWS Rule도 즉시 Disable, 아웃박스 

  Seller 비활성화에 의한 일괄 비활성화:
  - ✅ Seller INACTIVE 시 모든 스케줄 INACTIVE (확인됨)
  - ❓ 이 경우도 히스토리에 기록

  ---
  📦 Outbox Pattern

  Outbox Event 속성:
  - eventId: Long
  - eventType: String (SCHEDULER_CREATED, SCHEDULER_UPDATED, SCHEDULER_DELETED)
  - aggregateId: Long (schedulerId)
  - payload: JSON (AWS EventBridge 요청 데이터)
  - status: OutboxStatus (PENDING, PUBLISHED, FAILED)
  - retryCount: Integer
  - maxRetries: Integer (기본값 3)
  - createdAt, processedAt

  비즈니스 규칙:
  - ❓ 재시도 전략은
    - 재시도 간격: Exponential Backoff (1분 → 5분 → 15분) 또는 지터
    - 최대 재시도 횟수: 3회?
    - 모든 재시도 실패 시 처리는? -> 슬랙 알림 발송
  - ❓ Outbox 정리 전략:
    - PUBLISHED 상태 이벤트는 언제 삭제? (30일 후)
    - FAILED 상태 이벤트는 영구 보관?

  ---
  ⚙️ 3단계: Application Layer - Transaction 경계

  이 부분이 매우 중요합니다! AWS EventBridge 호출을 어떻게 처리할지 결정해야 합니다.

  🔍 Transaction 경계 전략

  Option A: Outbox Pattern (추천)
  RegisterSchedulerUseCase:
  1. [트랜잭션 시작]
  2. Scheduler 저장
  3. Outbox Event 저장 (PENDING)
  4. [트랜잭션 커밋]
  5. [별도 프로세스, 비동기 다른 스레드 애프터 커밋 리스너] Outbox Event 처리
     - AWS EventBridge Rule 생성
     - 성공 시: Outbox → PUBLISHED
     - 실패 시: Outbox → FAILED, 재시도 스케줄링 초반엔 간단하게 스케쥴러 어노테이션으로 (멀티모듈이라 부트스트랩에 해당 스케쥴러 따로 러너블시킬거)



  질문:
  - ❓ 어떤 전략을 선호하시나요?
  - ❓ Outbox Pattern 사용 시, Outbox 처리는 어떻게 하나요?
    - Event-driven (TransactionSynchronization 활용) 여기서 실패하면 폴백용으로 스케쥴러가 처리하도록
    
  ---
  💾 4단계: Persistence Layer

  JPA Entity 목록:
  - SellerJpaEntity
  - CrawlingSchedulerJpaEntity
  - CrawlingSchedulerHistoryJpaEntity
  - CrawlingSchedulerOutboxEventJpaEntity

  동시성 제어:
  - ❓ Scheduler 등록 시 동시 요청 처리는?
    - Pessimistic Lock (SELECT FOR UPDATE)
  - ❓ Seller 상태 변경 시 동시 요청 처리는?
    - 여러 관리자가 동시에 비활성화 시도 시 -> 그럴일은 없음 왜냐 사용자 1명

  ---
  🌐 5단계: REST API Layer

  예상 API 엔드포인트:
  POST   /api/v1/sellers                    # 셀러 등록
  PATCH  /api/v1/sellers/{sellerId}/status  # 상태 변경
  GET    /api/v1/sellers/{sellerId}         # 셀러 조회
  GET    /api/v1/sellers       # 셀러 리스트 조회

  POST   /api/v1/sellers/{sellerId}/schedulers      # 스케줄 등록
  PATCH  /api/v1/schedulers/{schedulerId}           # 스케줄 수정
  GET    /api/v1/schedulers/{schedulerId}           # 스케줄 조회
  GET    /api/v1/schedulers/{schedulerId}/history   # 스케줄 이력 조회

  질문:
  - ❓ 인증/인가 필요한가요? 필요없음
  - ❓ 페이징 필요한 API는? (스케줄 목록 조회, 이력 조회)
  - ❓ 필터링 필요 (ACTIVE만 조회, 특정 Seller의 스케줄만 조회)

  ---
  🎯 다음 단계

  위 질문들에 답변해주시면, 구체화된 비즈니스 규칙을 바탕으로 완전한 PRD 문서를 생성하겠습니다!

  핵심 질문 요약 (우선순위 높은 것부터):
  1. Seller 비활성화 시 AWS EventBridge 실패 처리 전략 (A/B/C 중 선택)
  2. Outbox Pattern 사용 여부 및 재시도 전략
  3. Cron Expression 검증 규칙 (형식, 최소 간격)
  4. 스케줄 수정 가능 항목 (name/cron/status)
  5. 동시성 제어 전략 (Optimistic/Pessimistic Lock)