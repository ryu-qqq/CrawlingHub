1. 머스트잇 셀러를 등록 수정 한다.
2. 머스트잇 셀러의 아이디는 머스트잇에서 고유한 아이디이다.
3. 머스트잇 셀러를 기준으로 크롤링 주기를 설정 할 수 있다.
4. 주기는 셀러마다 다를 수 있다.
5. 주기는 수정할 수 있다.
6. aws의 이벤트 브릿지를 통해 api 서버의 엔드포인트를 트리거 하고 그게 크롤링 시작이다.

7. 크롤링은 아웃박스 패턴으로 크롤링 태스크라는 객체를 통해 주기가 관리된다.
8. 크롤링 태스크 저장 -> sqs -> 컨슈머 폴링 형태로 구성되어 있다.
9. 크롤링 태스크의 상태 관리가 필요하다 (대기 -> 발행 -> 진행 -> 완료 / 실패 / 재시도)
10. ecs로 api 서버 1대, sqs 워커 1대 이상일 수 있다.
11. 머스트잇 사이트는 https://m.web.mustit.co.kr 사이트를 유저 에이전트를 붙여 호출해야지만 쿠키에 token 키값을 받을 수 있다.
12. 유저 에이전트를 변경하면 새로운 비회원 토큰을 발급 받을 수 있다.
13. 유저 에이전트 풀을 만들어 각 에이전트들의 토큰을 특정 알고리즘을 통해 적절히 분배하여 사용한다.
14. 이때 에이전트는 토큰이 없다면 토큰을 발급받고 시간당 80회 토큰 버킷 리미터를 갖는다.
15. 토큰을 꺼내 요청을 보내는 기준으로 정확히 80회가 될 수 있도록 한다.
16. 만약 어느 에이전트든 429 응답을 받는 즉시 토큰을 폐기 후 유저 에이전트의 상태를 중지로 바꾼다.
17. 유저에이전트의 상태를 관리가 필요하다.
18. 미니샵 엔드포인트, 상품 상세 엔드포인트, 상품 옵션 엔드포인트가 있다.
19. 미니샵 엔드포인트의 리스폰스엔 총 상품 수 및 상품 리스트가 포함되어있다.
20. 크롤러 태스크를 통해 크롤링 되는 모든 결과 값은 로우 데이터로 s3 또는 rdb(mysql) 에 저장한다.
21. 
https://m.web.mustit.co.kr/mustit-api/facade-api/v1/searchmini-shop-search"?sellerId={seller_id}&pageNo={page}&pageSize={page_size}&order=LATEST

미니샵 엔드포인트를 최초 page 0, pageSize =1 로 보내고 이때 상품 카운트수를 구한 후 머스트잇 셀러의 총 상품 수를 구한다.
이를 500으로 나누어 총 상품수 / 500 으로 총 pageSize 500 만큼 몇 페이지를 크롤링 해야하는지를 구한 후 그 만큼 크롤러 태스크를 저장 후 발행한다. 그리고 머스트잇 셀러의 총 상품 수를 업데이트 한다.

22. 미니샵 엔드포인트 관련 크롤러 태스크를 폴링 하여 그 request url을 기반으로 요청하여 상품 리스트를 구한 후 상품 pk 아이디를 추출하여 
rdb에 상품 pk 아이디를 rdb에 저장한다.
상품 상세 , https://m.web.mustit.co.kr/mustit-api/facade-api/v1/item/{item_no}/detail/top
상품 옵션 , https://m.web.mustit.co.kr/mustit-api/legacy-api/v1/auction_products/{item_no}/options
엔드 포인트를 각각의 크롤러 태스크에 할당 후 저장한다음 발행한다.

23. 크롤링 상품의 완성 기준은 최소 미니샵, 상품 상세 및 상품 옵션이 각각 1번씩은 크롤링이 되어야 완벽한 내부 상품으로 변환이 가능하므로 이걸 기준으로 상품의 완성 기준을 정한다.

24. 상품 상세 및 상품 옵션의 데이터가 최초 등록시 로 데이터를 저장 한다. 그외 기존에 존재하는데 데이터가 변경됨을 감지했을땐 우리의 상품 서버에 전송해서 갱신을 해야하기 때문에 외부 전송을 위한 아웃박스 테이블을 저장 후 바로 외부 콜을 보내거나 sqs로 태운다.

25. 빠른 변경 감지를 위해 로 데이터의 해시값으 저장 하고 그걸 비교한다.
26. 외부 전송을 위한 아웃박스 테이블의 상태 관리를 해야한다.

27. 하루 기준으로 크롤링의 성공률 및 진행률에 대해 파악할 수 있어야한다.


